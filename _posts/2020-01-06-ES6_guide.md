---
title: "[JavaScript] ES6 Note"
categories: posts
tags:
 - JavaScript
date: 2020-01-06 00:00:00 -0400
---

[use strict]

- 스크립트나 함수 시작부분에 "use strict"; 를 선엄함으로써 스크립트 내 전역변수를 허용하지 않음

- 함수 호이스팅도 제한된다.
- ie9에서 지원 안된다.



[블록 스코프]

스코프 : 유효범위

es5 -> 함수스코프 = 함수에 의해서 생기는 변수의 유효범위가 결정

es6 -> 블럭스코프 = 블럭 {} 에 의해 유효범위가 결정

- 기존 es5에서 쓰던 var는 블록스코프 영향을 받지않는다

- es6의 블럭스코프는 let, const 에서만 영향받는다



[TDZ : temporal dead zone (임시 사각지대)]

TDZ : ecmascript에서 정의한 개념은 아니다.

- 기존 var : 변수명만 위로 끌어올리고 undefined로 인식

- let, const : 변수명만 위로 끌어올리고 끝. (어떤 값도 매칭되지않음)

let이나 const가 선언되기 전에 변수를 접근하려 하면 TDZ다.

let, const는 호이스팅은 하지만 TDZ로 인해 값이 매칭되지않음.

(다른책에는 호이스팅을 하지 않는다고도 하지만, 변수명은 끌어올린다)



[const]

const : 선언과 동시에 값을 할당 해줘야한다.

- 선언 당시 참조타입(객체 나 배열)로 선언했다면 객체나 배열 안의 값을 변경하거나, 추가 삭제 하는건 가능하다.



- 객체 값 변경

```
const OBJ = {

 prop1 : 1,

 prop2 : 2

}

OBJ.prop1 = 3

console.log(OBJ.prop1)  // 3 출력. 
```



- 배열 값 변경

```
const ARR = [0, 1, 2]

ARR.push(3)

delete ARR[1]

console.log(ARR)
```



참조타입 값 변경을 못하게 하려면 : `Object.freeze()`, `Object.defineProperty()` 사용

freeze 메소드는 es5에 있다. 이름 그대로 얼려버리기 기능

단 freeze 시킨 데이터가 참조형이면 내부 데이터가 또 변경 가능한 문제점이 있다

freeze() 문제 해결방안 

1. OBJ 자체를 얼린다.

2. OBJ 내부 프로퍼티들을 순회하면서 참조형이면 1번 반복..(재귀) deep cody 처럼 deep feeezing



[for문 에서의 const]

```
var obj = {
 prop1: 1,
 prop2: 2,
 prop3: 3
}

for (const prop in obj) {
 console.log(prop);  // 내부적으로 참조타입 데이터가 생성되니 열거가 된다.
}

for (const i = 0; i < 5; i++) {
 console.log(i);   // i에 값을 새로 할당하는거니 열거가 안된다.
}
```



[template literal]

- 백틱 `` 으로 문자열 생성 가능, ${} 로 변수값을 넣을 수 있다.

```
const a = `a`;
console.log(`${a}bcd`);
```



- 멀티라인의 경우 들여쓰기도 문자열로 인식하니 주의

```js
const a = `abc
  def
  ghij`
  console.log(a)
```



- ${} 는 문자열이므로 자동 toString 처리 된다.

```
console.log(`${[0, 1, 2]}`)      // 0, 1, 2 출력
console.log(`${{a:1, b:2}}`)     // 객체는 [object Object] 출력
console.log(`${function(){ return 1 }}`)   // 문자열 function(){ return 1 } 출력
console.log(`${(() => 1 )()}` + 1)   // 함수결과값 1 + 문자열 1이 더해져 11 출력
```



[forEach, map, reduce]  

(셋 다 es5부터 등장했지만 중요하니까 짚고가기)

- forEach : for문 돌리는거랑 같음
- map : for문을 돌려서 새로운 배열을 만드는 목적 (return 필수)
- reduce : for문을 돌려서 다른 무언가를 만드는 목적 (return 필수)



- 일반 for문으로 배열 값의 총 합 구하기

```
const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let b = 0;

for(let i = 0; i < a.length; i++){
    b += a[i];
}
// 55출력
```



- reduce 사용 (reduce는 인자값 중 누적값을 가진다)

```
const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const b = a.reduce(function(a, c){return a + c});
// affow function 사용시 더 직관적
const b = a.reduce((a, c) => a + c);
// 55출력
```



[default parameter]

- 함수 매개변수의 기본값을 지정할 수 있다.
- undefined 거나 누락된 값일 경우에만 기본값이 적용된다.

```
const test = function( val = 1, str = 'test' ){
	console.log(`${val} , ${str}`);
}
test();   // 인자가 없어도 기본값인 1, test 출력
```



- 디폴트값은 함수로 설정도 가능하다

```
const notVal = ()=>{
	return 1;
}
const test = (f = notVal(), s = notVal() )=>{
	console.log(`${f} + ${s} = ${f+s}`);
}
```





[나머지 연산자]

- 함수의 매개변수에서 es5에서의 arguments 대신, 나머지 연산자를 사용 할 수 있다.
- arguments는 유사배열이지만 나머지 연산자는 리얼 배열이다.

```
function test (a, b, ...c){   // ...을 앞에 붙이면 나머지 연산자
	console.log(c);
}
test(1, 2, 3, 4, 5);  // 3, 4, 5의 값을 배열로 출력
```





[화살표 함수]

- 일반함수는 함수를 호출할 때, 어떻게 호출되는지에 따라 this 바인딩이 결정되었지만(콜백함수 내부의 this는 window전역객체를 가리킨다.) 화살표 함수의 this는 상위 스코프의 this를 가리킨다.

- 화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.

- 화살표 함수와 es6의 축약 메소드 표현은 다르다.

```
//arrow function
const person = {
  name: 'Lee',
  sayHi: () => console.log(`Hi ${this.name  // 여기서 메소드의 this는 상위 컨텍스트인 window를 가리킨다. 여기서 화살표 함수를 사용하는건 바람직하지 않다.
};

//축약
const person = {
  name: 'Lee',
  sayHi() { // === sayHi: function() {
    console.log(`Hi ${this.name}`); // 메소드의 this는 자기자신(person) 이다.
  }
};
```

- 화살표 함수는 생성자 함수로 사용할 수 없다. (화살표 함수는 prototype 프로퍼티가 없다.)

```
const Foo = () => {};

// 화살표 함수는 prototype 프로퍼티가 없다
console.log(Foo.hasOwnProperty('prototype')); // false

const foo = new Foo(); // TypeError: Foo is not a constructor
```

